<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>leapc: Leap Years in C for Embedded Systems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">leapc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Leap Years in C for Embedded Systems </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> This repo delves into the intricacies of leap years, exploring their historical context, the rules governing their occurrence, and practical methods for calculating them in embedded systems. We discuss the significance of leap years in maintaining calendar accuracy and provide efficient algorithms suitable for resource-constrained environments. The article also highlights common pitfalls and best practices for implementing leap year calculations in C programming, ensuring reliability and precision in timekeeping applications.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
The Problem</h1>
<p>What is a leap year? In simple mathematical terms,</p>
<p>$$ f_{leap}(year) = ( year \bmod 4 = 0 ) \land \left[ (year \bmod 100 \neq 0) \lor (year \bmod 400 = 0) \right] $$</p>
<p>where $x\bmod y$ is the integer “modulo” operation: the remainder after dividing a numerator by a denominator; the modulo operation computes the “modulus.”</p>
<p>Developing a super-simple library for manipulating Gregorian epoch times that account for leap years is the goal of this article. Such a library has no low-level dependencies. It depends only on raw C, making it suitable for embedded systems.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Does a Year Leap?</h2>
<p>In basic C, the <code>is_leap</code> function answers <code>true</code> or <code>false</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code hl_function" href="leap_8h.html#a8fceec1f878ad8b0f44bb23d5ec96351">is_leap</a>(<span class="keywordtype">int</span> year) {</div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">   * Allow C99&#39;s standard precedence to rule over operator ordering: modulo</span></div>
<div class="line"><span class="comment">   * exceeds equality and inequality operators.</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keywordflow">return</span> year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0);</div>
<div class="line">}</div>
<div class="ttc" id="aleap_8h_html_a8fceec1f878ad8b0f44bb23d5ec96351"><div class="ttname"><a href="leap_8h.html#a8fceec1f878ad8b0f44bb23d5ec96351">is_leap</a></div><div class="ttdeci">bool is_leap(int year)</div><div class="ttdoc">Determine if a year is a leap year.</div><div class="ttdef"><b>Definition</b> <a href="leap_8c_source.html#l00013">leap.c:13</a></div></div>
</div><!-- fragment --><p>Notice that $year$ exists in integer space: $year\in\mathbb{Z}$. This is by design and not just for performance. A year is a whole number for the purpose of leap determination. For contemporary embedded systems, an integer is typically a signed 32-bit number; this provides more than enough resolution for epoch years, which would normally fall between $1970$ and $2025$, the current year.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
The Solution</h1>
<p>Computing leap years through a range requires a specialised quotient-modulo function that handles negative divisors correctly. The following sections expand on this issue and walk through the complete implementation.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Leap Through the Years</h2>
<p>Another way of looking at the leap year formula exists. For some $year$, the following sum gives the total number of “leap years” <em>through</em> the range $thru_{leap}\in\left[0, year\right)$.</p>
<p>$$ thru_{leap}\in\left[0, year\right)=f_{quo}(year, 4) - f_{quo}(year, 100) + f_{quo}(year, 400) $$</p>
<p>Note carefully: the exclusive upper boundary. This is important. The sum does not include the given year; it includes all the years up to the year, but not the year itself. The $f_{quo}$ function computes the integer quotient of its two arguments.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Quotient and modulus</h3>
<p>The $f_{quo}(x, y)$ function amounts to, in C:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structquo__mod.html">quo_mod</a> {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="structquo__mod.html#ad5a86f734615359e37e00199b955d02c">quo</a>;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">mod</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code hl_struct" href="structquo__mod.html">quo_mod</a> <a class="code hl_struct" href="structquo__mod.html">quo_mod</a>(int x, int y) {</div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">   * Compute modulus using C&#39;s % operator. Note that C&#39;s % operator will yield</span></div>
<div class="line"><span class="comment">   * negative results when the numerator is negative.</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">mod</a> = x % y;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Adjust negative modulus to be positive. Ensures that:</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   *    0 &lt;= mod &lt; y    when y &gt; 0</span></div>
<div class="line"><span class="comment">   *    y &lt; mod &lt;= 0    when y &lt; 0</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * This matches Lua&#39;s modulo operator behaviour.</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_variable" href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">mod</a> != 0 &amp;&amp; (<a class="code hl_variable" href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">mod</a> ^ y) &lt; 0) {</div>
<div class="line">    <a class="code hl_variable" href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">mod</a> += y;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">   * Returns a quo_mod structure by casting an initialiser. Is this portable?</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code hl_struct" href="structquo__mod.html">quo_mod</a>){.<a class="code hl_variable" href="structquo__mod.html#ad5a86f734615359e37e00199b955d02c">quo</a> = (x - <a class="code hl_variable" href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">mod</a>) / y, .<a class="code hl_variable" href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">mod</a> = <a class="code hl_variable" href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">mod</a>};</div>
<div class="line">}</div>
<div class="ttc" id="astructquo__mod_html"><div class="ttname"><a href="structquo__mod.html">quo_mod</a></div><div class="ttdoc">Quotient and remainder in integer space.</div><div class="ttdef"><b>Definition</b> <a href="quo__mod_8h_source.html#l00022">quo_mod.h:22</a></div></div>
<div class="ttc" id="astructquo__mod_html_acb2142e286cf82a7b71f60b079a25d09"><div class="ttname"><a href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">quo_mod::mod</a></div><div class="ttdeci">int mod</div><div class="ttdoc">Integer modulus.</div><div class="ttdef"><b>Definition</b> <a href="quo__mod_8h_source.html#l00030">quo_mod.h:30</a></div></div>
<div class="ttc" id="astructquo__mod_html_ad5a86f734615359e37e00199b955d02c"><div class="ttname"><a href="structquo__mod.html#ad5a86f734615359e37e00199b955d02c">quo_mod::quo</a></div><div class="ttdeci">int quo</div><div class="ttdoc">Integer quotient.</div><div class="ttdef"><b>Definition</b> <a href="quo__mod_8h_source.html#l00026">quo_mod.h:26</a></div></div>
</div><!-- fragment --><p>The implementation tracks Lua’s module operator. The sign differs. In C, the sign of the modulus follows the sign of the numerator, but for Lua, it follows the sign of the divisor. The C implementation needs a small correction; add the divisor if the signs differ between the modulus and the divisor.</p>
<p>$$ \begin{aligned} m' &amp;= x \bmod y \ m &amp;= \begin{cases} m' + y &amp; \text{if } m' \neq 0 \text{ and } \text{sgn}(m') \neq \text{sgn}(y) \ m' &amp; \text{otherwise} \end{cases} \ q &amp;= \frac{x - m}{y} \end{aligned} $$</p>
<p>Properties include:</p>
<p>$$ \begin{aligned} 0 \leq m &lt; y &amp; \quad \text{when } y &gt; 0 \ y &lt; m \leq 0 &amp; \quad \text{when } y &lt; 0 \end{aligned} $$</p>
<p>And the invariant $x = y \cdot q + m$ applies. The simple reason for this disparity between Lua and C boils down to the fact that Lua uses only floating-point numbers at version $5.1$. For that reason, it computes <code>%</code> in $\mathbb{R}$ space using division and “floor” as follows.</p>
<p>$$ \text{luai}_{nummod}(a, b) = a - \left\lfloor \frac{a}{b} \right\rfloor \cdot b $$</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Leap through implementation in C</h3>
<p>The “leap years through some year” function in C amounts to a simple sum of quotients.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(<span class="keywordtype">int</span> year) {</div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">   * Expand the quotient terms first for debugging. Make it easier to see the</span></div>
<div class="line"><span class="comment">   * terms of the thru-sum.</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> q4 = <a class="code hl_struct" href="structquo__mod.html">quo_mod</a>(year, 4).<a class="code hl_variable" href="structquo__mod.html#ad5a86f734615359e37e00199b955d02c">quo</a>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> q100 = <a class="code hl_struct" href="structquo__mod.html">quo_mod</a>(year, 100).<a class="code hl_variable" href="structquo__mod.html#ad5a86f734615359e37e00199b955d02c">quo</a>;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> q400 = <a class="code hl_struct" href="structquo__mod.html">quo_mod</a>(year, 400).<a class="code hl_variable" href="structquo__mod.html#ad5a86f734615359e37e00199b955d02c">quo</a>;</div>
<div class="line">  <span class="keywordflow">return</span> q4 - q100 + q400;</div>
<div class="line">}</div>
<div class="ttc" id="aleap_8h_html_a0624e505754fbcf36363ec6e0e90c51f"><div class="ttname"><a href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a></div><div class="ttdeci">int leap_thru(int year)</div><div class="ttdoc">Leap years completed from year 0 up to but not including the first day of the specified year.</div><div class="ttdef"><b>Definition</b> <a href="leap_8c_source.html#l00030">leap.c:30</a></div></div>
</div><!-- fragment --><p>The implementation expands the quotient terms for clarity; they make debugging easier since each term appears separately in the debugger. The following unit tests verify the implementation.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="leap_8h.html">leap.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> leap_thru_test(<span class="keywordtype">void</span>) {</div>
<div class="line">  assert(<a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(0) == 0);</div>
<div class="line">  assert(<a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(1) == 0);</div>
<div class="line">  assert(<a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(2) == 0);</div>
<div class="line">  assert(<a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(3) == 0);</div>
<div class="line">  assert(<a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(4) == 1);</div>
<div class="line">  assert(<a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(5) == 1);</div>
<div class="line">  assert(<a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(100) == 24);</div>
<div class="line">  assert(<a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(101) == 24);</div>
<div class="line">  assert(<a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(200) == 48);</div>
<div class="line">  assert(<a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(201) == 48);</div>
<div class="line">  assert(<a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(400) == 97);</div>
<div class="line">  assert(<a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(401) == 97);</div>
<div class="line">}</div>
<div class="ttc" id="aleap_8h_html"><div class="ttname"><a href="leap_8h.html">leap.h</a></div><div class="ttdoc">Leap year function prototypes.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Leap-Adjusted Days and Offset</h2>
<p>Now that the leap library can compute the number of leap years in the range $[0,year)$, the number of days in that range becomes readily derived. Start by assuming $365$ days per year <em>without</em> adjustment. Apply the leap-through adjustment for all the preceding years. The result is the number of epoch days starting at year $0$ and ending at the given $year$.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code hl_function" href="leap_8h.html#af525dd5618ca8ad6d155cc2dafcc5b02">leap_day</a>(<span class="keywordtype">int</span> year) {</div>
<div class="line">  <span class="keywordflow">return</span> year * 365 + <a class="code hl_function" href="leap_8h.html#a0624e505754fbcf36363ec6e0e90c51f">leap_thru</a>(year - 1) + 1;</div>
<div class="line">}</div>
<div class="ttc" id="aleap_8h_html_af525dd5618ca8ad6d155cc2dafcc5b02"><div class="ttname"><a href="leap_8h.html#af525dd5618ca8ad6d155cc2dafcc5b02">leap_day</a></div><div class="ttdeci">int leap_day(int year)</div><div class="ttdoc">Counts leap-adjusted days up to some year.</div><div class="ttdef"><b>Definition</b> <a href="leap_8c_source.html#l00048">leap.c:48</a></div></div>
</div><!-- fragment --><p>The $+1$ in <code>leap_day</code> anchors the epoch so that the start of year $0$ maps to day $0$ while still counting year $0$ as a leap year. The closed-form term <code>year * 365 + leap_thru(year - 1)</code> counts $365$-day years plus leap days up to (but not including) the target year; because year $0$ itself is a leap year in the proleptically[^1] applied Gregorian model, that formula alone would put <code>leap_day(0)</code> at $-1$ and undercount every subsequent absolute day number by one. Adding $1$ fixes the baseline: <code>leap_day(0)</code> becomes $0$, <code>leap_day(1)</code> becomes $366$[^2] and differences between years remain correct because the constant offsets cancel in subtractions.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Leap offset</h3>
<p>The <code><a class="el" href="structleap__off.html" title="Leap offset by year and day.">leap_off</a></code> function (see implementation below) normalises an arbitrary day offset relative to a given year into a canonical $(year, day_{of_{year}})$ pair where $0 \le day_{of_{year}} &lt; days_{in_{year}}$. Its algorithm works as follows:</p>
<ul>
<li>Compute the current year’s length: <code>days = 365 + leap_add(year)</code>.</li>
<li>While $day$ lies outside $[0, days)$:<ul>
<li>Jump whole years using floor-like quotient semantics: <code>year0 = year + <a class="el" href="structquo__mod.html" title="Quotient and remainder in integer space.">quo_mod(day, days)</a>.quo</code>.</li>
<li>Rebase the offset to the new year using absolute day counts: <code>day += leap_day(year) - leap_day(year0)</code>.</li>
<li>Update <code>year</code> to <code>year0</code> and recompute <code>days</code> for that year.</li>
</ul>
</li>
<li>Return the resulting <code>(struct <a class="el" href="structleap__off.html" title="Leap offset by year and day.">leap_off</a>){year, day}</code> which is within the year’s bounds.</li>
</ul>
<p>Notes:</p>
<ul>
<li><code><a class="el" href="structquo__mod.html" title="Quotient and remainder in integer space.">quo_mod</a></code> uses Lua-style modulo semantics, so negative offsets jump the correct number of whole years in the negative direction.</li>
<li>Differences of <code>leap_day(year)</code> cancel the constant epoch offset, ensuring exact rebasing regardless of the $+1$ anchor in <code>leap_day</code>.</li>
</ul>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structleap__off.html">leap_off</a> {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="structleap__off.html#adbe52994b637f6e5f60225a3300b2ac3">year</a>;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="structleap__off.html#abfced6c902115427f236f9d210728b03">day</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code hl_struct" href="structleap__off.html">leap_off</a> <a class="code hl_struct" href="structleap__off.html">leap_off</a>(int <a class="code hl_variable" href="structleap__off.html#adbe52994b637f6e5f60225a3300b2ac3">year</a>, int day_off) {</div>
<div class="line">  <span class="keywordtype">int</span> days = 365 + <a class="code hl_function" href="leap_8h.html#adc35a7cfe1e01d9fa2d71aa9dcd8fdd9">leap_add</a>(<a class="code hl_variable" href="structleap__off.html#adbe52994b637f6e5f60225a3300b2ac3">year</a>);</div>
<div class="line">  <span class="keywordflow">while</span> (day_off &lt; 0 || day_off &gt;= days) {</div>
<div class="line">    <span class="keywordtype">int</span> year0 = <a class="code hl_variable" href="structleap__off.html#adbe52994b637f6e5f60225a3300b2ac3">year</a> + <a class="code hl_struct" href="structquo__mod.html">quo_mod</a>(day_off, days).<a class="code hl_variable" href="structquo__mod.html#ad5a86f734615359e37e00199b955d02c">quo</a>;</div>
<div class="line">    day_off += <a class="code hl_function" href="leap_8h.html#af525dd5618ca8ad6d155cc2dafcc5b02">leap_day</a>(<a class="code hl_variable" href="structleap__off.html#adbe52994b637f6e5f60225a3300b2ac3">year</a>) - <a class="code hl_function" href="leap_8h.html#af525dd5618ca8ad6d155cc2dafcc5b02">leap_day</a>(year0);</div>
<div class="line">    days = 365 + <a class="code hl_function" href="leap_8h.html#adc35a7cfe1e01d9fa2d71aa9dcd8fdd9">leap_add</a>(<a class="code hl_variable" href="structleap__off.html#adbe52994b637f6e5f60225a3300b2ac3">year</a> = year0);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code hl_struct" href="structleap__off.html">leap_off</a>){.year = <a class="code hl_variable" href="structleap__off.html#adbe52994b637f6e5f60225a3300b2ac3">year</a>, .day = day_off};</div>
<div class="line">}</div>
<div class="ttc" id="aleap_8h_html_adc35a7cfe1e01d9fa2d71aa9dcd8fdd9"><div class="ttname"><a href="leap_8h.html#adc35a7cfe1e01d9fa2d71aa9dcd8fdd9">leap_add</a></div><div class="ttdeci">int leap_add(int year)</div><div class="ttdoc">Adds one for a leap year otherwise zero.</div><div class="ttdef"><b>Definition</b> <a href="leap_8c_source.html#l00028">leap.c:28</a></div></div>
<div class="ttc" id="astructleap__off_html"><div class="ttname"><a href="structleap__off.html">leap_off</a></div><div class="ttdoc">Leap offset by year and day.</div><div class="ttdef"><b>Definition</b> <a href="leap_8h_source.html#l00077">leap.h:77</a></div></div>
<div class="ttc" id="astructleap__off_html_abfced6c902115427f236f9d210728b03"><div class="ttname"><a href="structleap__off.html#abfced6c902115427f236f9d210728b03">leap_off::day</a></div><div class="ttdeci">int day</div><div class="ttdoc">Day of year offset.</div><div class="ttdef"><b>Definition</b> <a href="leap_8h_source.html#l00085">leap.h:85</a></div></div>
<div class="ttc" id="astructleap__off_html_adbe52994b637f6e5f60225a3300b2ac3"><div class="ttname"><a href="structleap__off.html#adbe52994b637f6e5f60225a3300b2ac3">leap_off::year</a></div><div class="ttdeci">int year</div><div class="ttdoc">Year offset.</div><div class="ttdef"><b>Definition</b> <a href="leap_8h_source.html#l00081">leap.h:81</a></div></div>
</div><!-- fragment --><p>Notice that the <code>day_off</code> parameter is zero-based: the first day of the year is day $0$. This argument is a day <em>offset</em> relative to some year, not a one-based day of the month. This is an important distinction. The day is a zero-based offset in days compared to some base year. The function returns a <code>struct <a class="el" href="structleap__off.html" title="Leap offset by year and day.">leap_off</a></code> containing the adjusted year and day; also an offset.</p>
<p>This is a key function for manipulating epoch days in embedded systems where no standard library exists. It allows day offsets to be normalised into year-and-day pairs that embedded applications can use for date calculations. Relative leap-year computations become straightforward, as in the following example.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Negative day offset that normalises to the previous year.</span></div>
<div class="line"><span class="comment"> * Year 5 offset -1 day normalises to year 4 day 365 (leap year).</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">assert(<a class="code hl_function" href="leap_8h.html#a00361f152b7493548e05449e8715e0d7">equal_leap_off</a>((<span class="keyword">struct</span> <a class="code hl_struct" href="structleap__off.html">leap_off</a>){4, 365}, <a class="code hl_struct" href="structleap__off.html">leap_off</a>(5, -1)));</div>
<div class="ttc" id="aleap_8h_html_a00361f152b7493548e05449e8715e0d7"><div class="ttname"><a href="leap_8h.html#a00361f152b7493548e05449e8715e0d7">equal_leap_off</a></div><div class="ttdeci">static bool equal_leap_off(struct leap_off lhs, struct leap_off rhs)</div><div class="ttdoc">Compares two leap_off structures for equality.</div><div class="ttdef"><b>Definition</b> <a href="leap_8h_source.html#l00105">leap.h:105</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
Month and Year Day</h2>
<p>Given some $year$ and some $1\le month\le12$ ordinal, computing the days in the month or the days of the year for that month becomes straightforward, and a date (year, month ordinal, day of month ordinal) from a year-day offset conversion falls out.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="leap_8h.html#a5462fa371f5c6160f06b9590e3fe71c4">leap_mday</a>(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month) {</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> MDAY[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">struct </span><a class="code hl_struct" href="structquo__mod.html">quo_mod</a> qm = <a class="code hl_struct" href="structquo__mod.html">quo_mod</a>(month - 1, 12);</div>
<div class="line">  <span class="keywordflow">return</span> MDAY[qm.<a class="code hl_variable" href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">mod</a>] + (qm.<a class="code hl_variable" href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">mod</a> == 1 ? <a class="code hl_function" href="leap_8h.html#adc35a7cfe1e01d9fa2d71aa9dcd8fdd9">leap_add</a>(year + qm.<a class="code hl_variable" href="structquo__mod.html#ad5a86f734615359e37e00199b955d02c">quo</a>) : 0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="leap_8h.html#af5c6cbfa3c41db28de51788f77713acf">leap_yday</a>(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month) {</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> YDAY[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">struct </span><a class="code hl_struct" href="structquo__mod.html">quo_mod</a> qm = <a class="code hl_struct" href="structquo__mod.html">quo_mod</a>(month - 1, 12);</div>
<div class="line">  <span class="keywordflow">return</span> YDAY[qm.<a class="code hl_variable" href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">mod</a>] + (qm.<a class="code hl_variable" href="structquo__mod.html#acb2142e286cf82a7b71f60b079a25d09">mod</a> &gt; 1 ? <a class="code hl_function" href="leap_8h.html#adc35a7cfe1e01d9fa2d71aa9dcd8fdd9">leap_add</a>(year + qm.<a class="code hl_variable" href="structquo__mod.html#ad5a86f734615359e37e00199b955d02c">quo</a>) : 0);</div>
<div class="line">}</div>
<div class="ttc" id="aleap_8h_html_a5462fa371f5c6160f06b9590e3fe71c4"><div class="ttname"><a href="leap_8h.html#a5462fa371f5c6160f06b9590e3fe71c4">leap_mday</a></div><div class="ttdeci">int leap_mday(int year, int month)</div><div class="ttdoc">Day of month from year and month.</div><div class="ttdef"><b>Definition</b> <a href="leap_8c_source.html#l00080">leap.c:80</a></div></div>
<div class="ttc" id="aleap_8h_html_af5c6cbfa3c41db28de51788f77713acf"><div class="ttname"><a href="leap_8h.html#af5c6cbfa3c41db28de51788f77713acf">leap_yday</a></div><div class="ttdeci">int leap_yday(int year, int month)</div><div class="ttdoc">Day of year from year and month.</div><div class="ttdef"><b>Definition</b> <a href="leap_8c_source.html#l00086">leap.c:86</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
Leap Date</h3>
<p>The year-day offset to date normalisation function applies the following algorithm for Converting a (year, day-of-year cardinal offset) pair into a (year, month ordinal, day-of-month ordinal) triple.</p>
<ul>
<li>Normalise the (year, day) pair using <a class="el" href="structleap__off.html" title="Leap offset by year and day.">leap_off</a> to ensure day is within the year’s bounds.</li>
<li>Iterate months from 1 to 12, subtracting the number of days in each month from day until day is less than the number of days in the current month.</li>
<li>The current month is the target month, and day + 1 is the target day of the month (to convert from 0-based to 1-based).</li>
</ul>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structleap__date.html">leap_date</a> {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="structleap__date.html#a2592d9561ec40722409dccce80e279ab">year</a>;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="structleap__date.html#ab236ca424c309ab5d4e90adf9642522b">month</a>;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="structleap__date.html#af298f0ea5fb406b2e02aa35d3c68c71f">day</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span><a class="code hl_struct" href="structleap__date.html">leap_date</a> <a class="code hl_struct" href="structleap__date.html">leap_date</a>(int <a class="code hl_variable" href="structleap__date.html#a2592d9561ec40722409dccce80e279ab">year</a>, int day_off) {</div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_struct" href="structleap__off.html">leap_off</a> off = <a class="code hl_struct" href="structleap__off.html">leap_off</a>(<a class="code hl_variable" href="structleap__date.html#a2592d9561ec40722409dccce80e279ab">year</a>, day_off);</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="structleap__date.html#ab236ca424c309ab5d4e90adf9642522b">month</a> = 1;</div>
<div class="line">  <span class="keywordflow">for</span> (; <a class="code hl_variable" href="structleap__date.html#ab236ca424c309ab5d4e90adf9642522b">month</a> &lt;= 12; ++<a class="code hl_variable" href="structleap__date.html#ab236ca424c309ab5d4e90adf9642522b">month</a>) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> mday = <a class="code hl_function" href="leap_8h.html#a5462fa371f5c6160f06b9590e3fe71c4">leap_mday</a>(off.<a class="code hl_variable" href="structleap__off.html#adbe52994b637f6e5f60225a3300b2ac3">year</a>, <a class="code hl_variable" href="structleap__date.html#ab236ca424c309ab5d4e90adf9642522b">month</a>);</div>
<div class="line">    <span class="keywordflow">if</span> (off.<a class="code hl_variable" href="structleap__off.html#abfced6c902115427f236f9d210728b03">day</a> &lt; mday) {</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    off.<a class="code hl_variable" href="structleap__off.html#abfced6c902115427f236f9d210728b03">day</a> -= mday;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code hl_struct" href="structleap__date.html">leap_date</a>){</div>
<div class="line">      .year = off.<a class="code hl_variable" href="structleap__off.html#adbe52994b637f6e5f60225a3300b2ac3">year</a>,</div>
<div class="line">      .month = <a class="code hl_variable" href="structleap__date.html#ab236ca424c309ab5d4e90adf9642522b">month</a>,</div>
<div class="line">      .day = off.<a class="code hl_variable" href="structleap__off.html#abfced6c902115427f236f9d210728b03">day</a> + 1,</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="ttc" id="astructleap__date_html"><div class="ttname"><a href="structleap__date.html">leap_date</a></div><div class="ttdoc">Leap year date structure.</div><div class="ttdef"><b>Definition</b> <a href="leap_8h_source.html#l00163">leap.h:163</a></div></div>
<div class="ttc" id="astructleap__date_html_a2592d9561ec40722409dccce80e279ab"><div class="ttname"><a href="structleap__date.html#a2592d9561ec40722409dccce80e279ab">leap_date::year</a></div><div class="ttdeci">int year</div><div class="ttdoc">Year.</div><div class="ttdef"><b>Definition</b> <a href="leap_8h_source.html#l00167">leap.h:167</a></div></div>
<div class="ttc" id="astructleap__date_html_ab236ca424c309ab5d4e90adf9642522b"><div class="ttname"><a href="structleap__date.html#ab236ca424c309ab5d4e90adf9642522b">leap_date::month</a></div><div class="ttdeci">int month</div><div class="ttdoc">Month of year starting from 1 for January.</div><div class="ttdef"><b>Definition</b> <a href="leap_8h_source.html#l00174">leap.h:174</a></div></div>
<div class="ttc" id="astructleap__date_html_af298f0ea5fb406b2e02aa35d3c68c71f"><div class="ttname"><a href="structleap__date.html#af298f0ea5fb406b2e02aa35d3c68c71f">leap_date::day</a></div><div class="ttdeci">int day</div><div class="ttdoc">Day of month starting from 1 for the first day of the month.</div><div class="ttdef"><b>Definition</b> <a href="leap_8h_source.html#l00181">leap.h:181</a></div></div>
</div><!-- fragment --><p>We can now translate year-day pairs to year-month-day triples.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Three hundred and sixty five days from midnight on 1900-01-01 is 1900-12-31</span></div>
<div class="line"><span class="comment"> * since 1900 is not a leap year.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">assert(<a class="code hl_function" href="leap_8h.html#ada49db2df2689b249acfb50ebe09a28f">equal_leap_date</a>((<span class="keyword">struct</span> <a class="code hl_struct" href="structleap__date.html">leap_date</a>){1900, 12, 31}, <a class="code hl_struct" href="structleap__date.html">leap_date</a>(1900, 364)));</div>
<div class="ttc" id="aleap_8h_html_ada49db2df2689b249acfb50ebe09a28f"><div class="ttname"><a href="leap_8h.html#ada49db2df2689b249acfb50ebe09a28f">equal_leap_date</a></div><div class="ttdeci">static bool equal_leap_date(struct leap_date lhs, struct leap_date rhs)</div><div class="ttdoc">Compares two leap_date structures for equality.</div><div class="ttdef"><b>Definition</b> <a href="leap_8h_source.html#l00193">leap.h:193</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md11"></a>
Conclusions</h1>
<p>The <code>leapc</code> (leap years in C) mini-library provides a lightweight, self-contained implementation of leap year calculations suitable for embedded systems with minimal dependencies. The implementation is fast and portable, relying only on basic integer arithmetic and division—no heavy floating-point operations or external libraries required. This makes it ideal for embedded firmware deployments where code footprint and computational efficiency matter.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Day-Level Resolution</h2>
<p>The library operates at day-level granularity, which covers most calendar applications. Extending to timestamps is straightforward: divide a time value in seconds by $86400$ (seconds per day) to obtain a quotient and remainder. The remainder gives the time-of-day (seconds since midnight), and the quotient represents the epoch day.</p>
<p>To convert to a specific epoch—such as Unix time (1970-01-01) just subtract <code>leap_day(1970)</code> from the quotient. This flexibility is a key strength: the library itself is epoch-agnostic. Callers can anchor to any convenient year: <code>leap_day(1900)</code> for the Gregorian epoch, <code>leap_day(2000)</code> for Windows NT time, or any other reference point. This design avoids baking a single epoch assumption into the core algorithms.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Scope and Future Work</h2>
<p>The implementation handles positive years and works well for contemporary applications spanning 1970 through 9999. It assumes the proleptically-extended Gregorian calendar (applying modern leap rules backward to year 0). Handling negative years (B.C. dates) or extending beyond year 9999 would require minor adjustments but is not addressed in this version.</p>
<p>The complete implementation, test suite, and usage examples are available on <a href="https://github.com/royratcliffe/leapc">GitHub</a>. For embedded developers seeking a minimal, efficient leap year library, <code>leapc</code> offers a practical solution.</p>
<p>The library has limitations: it does not handle negative B.C. years. Nor does it address timezone considerations.</p>
<p>[^1]: The computations apply the Gregorian model back to Julian time. Pope Gregory XIII’s issued the papal bull in 1582.</p>
<p>[^2]: $365$ regular days plus the leap day of year $0$ </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
